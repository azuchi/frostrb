module FROST
  # A secret share generated by performing a (t-out-of-n) secret sharing scheme.
  class SecretShare
    attr_reader :identifier
    attr_reader :share
    attr_reader :context

    # Generate secret share.
    # @param [FROST::Context] context
    # @param [Integer] identifier Identifier of this share.
    # @param [Integer] share A share.
    def initialize(context, identifier, share)
      raise ArgumentError, "identifier must be Integer." unless identifier.is_a?(Integer)
      raise ArgumentError, "share must be Integer." unless share.is_a?(Integer)
      raise ArgumentError "context must be FROST::Context." unless context.is_a?(FROST::Context)

      @identifier = identifier
      @share = share
      @context = context
    end

    # Get the group
    # @return [ECDSA::Group]
    def group
      context.group
    end

    # Compute public key.
    # @return [ECDSA::Point]
    def to_point
      group.generator * share
    end

    # Generate a signing share key.
    # @return [FROST::SigningKey]
    def to_key
      FROST::SigningKey.new(context, share)
    end

    # Generate hiding and binding nance.
    # @return [Array] An array of hiding nonce and binding nonce.
    def generate_nonces
      key = to_key
      [ FROST::Nonce.gen_from_secret(key), FROST::Nonce.gen_from_secret(key) ]
    end

    # Add +other+ secret share.
    # @param [FROST:SecretShare] other
    # @raise [ArgumentError]
    # @return [FROST::SecretShare]
    def add(other)
      raise ArgumentError, "other must be FROST::SecretShare." unless other.is_a?(FROST::SecretShare)
      raise ArgumentError, "identifier mismatch." unless other.identifier == identifier
      field = ECDSA::PrimeField.new(context.group.order)
      FROST::SecretShare.new(context, identifier, field.mod(share + other.share))
    end
    alias + add
  end
end
